//go:build windows

package main

import (
	"fmt"
	"net"
	"os"
	"os/exec"
	"path/filepath"

	"golang.org/x/sys/windows"
	"golang.zx2c4.com/wintun"
)

type TunDevice struct {
	adapter *wintun.Adapter
	session wintun.Session
	name    string
}

const (
	WINTUN_DLL          = "wintun.dll"
	WINTUN_DOWNLOAD_URL = "https://www.wintun.net/"
)

func createTunDevice(name string) (*TunDevice, error) {
	// Get absolute path to executable's directory
	exe, err := os.Executable()
	if err != nil {
		debugLog("Failed to get executable path: %v", err)
		return nil, err
	}
	exePath := filepath.Dir(exe)
	debugLog("Executable path: %s", exePath)

	// Try both System32 and local paths
	dllPaths := []string{
		`C:\Windows\System32\wintun.dll`,
		filepath.Join(exePath, "wintun.dll"),
	}

	var handle windows.Handle
	var loadError error

	for _, dllPath := range dllPaths {
		debugLog("Trying to load: %s", dllPath)

		// Check if file exists and is readable
		if _, err := os.Stat(dllPath); err != nil {
			debugLog("File check failed: %v", err)
			continue
		}

		// Try to load using direct Windows API
		handle, loadError = windows.LoadLibraryEx(dllPath, 0, windows.LOAD_WITH_ALTERED_SEARCH_PATH)
		if handle != 0 {
			debugLog("Successfully loaded DLL from: %s", dllPath)
			break
		}
		debugLog("LoadLibrary failed: %v (error code: %d)", loadError, windows.GetLastError())
	}

	if handle == 0 {
		return nil, fmt.Errorf("failed to load wintun.dll: %v", loadError)
	}
	defer windows.FreeLibrary(handle)

	// Try to initialize Wintun with more detailed logging
	guid, err := windows.GUIDFromString("{56B4895A-C9E8-45B4-9C72-4EAAF6B6D65B}")
	if err != nil {
		return nil, fmt.Errorf("error creating GUID: %v", err)
	}

	debugLog("Creating adapter with name: %s", name)
	adapter, err := wintun.CreateAdapter(name, "Doxx", &guid)
	if err != nil {
		debugLog("Failed to create adapter: %v (error code: %d)", err, windows.GetLastError())
		return nil, fmt.Errorf("error creating Wintun adapter: %v", err)
	}
	debugLog("Adapter created successfully")

	debugLog("Starting adapter session")
	session, err := adapter.StartSession(0x800000) // 8MB ring buffer
	if err != nil {
		debugLog("Session start failed: %v", err)
		adapter.Close()
		return nil, fmt.Errorf("error starting Wintun session: %v", err)
	}
	debugLog("Session started successfully")

	// Verify adapter exists in Windows
	debugLog("Verifying adapter in network interfaces")
	ifaces, err := net.Interfaces()
	if err == nil {
		for _, iface := range ifaces {
			debugLog("Found interface: %s", iface.Name)
		}
	}

	debugLog("Setting up TUN interface %s", name)

	// Get interface index first
	getIndexCmd := exec.Command("powershell", "-Command",
		fmt.Sprintf(`(Get-NetAdapter -Name "%s").ifIndex`, name))
	indexOutput, err := getIndexCmd.CombinedOutput()
	if err != nil {
		debugLog("Failed to get interface index: %v\nOutput: %s", err, indexOutput)
		adapter.Close()
		return nil, fmt.Errorf("failed to get interface index: %v", err)
	}
	debugLog("Got interface index: %s", string(indexOutput))

	// Disable IPv6 on the interface
	disableIPv6Cmd := exec.Command("netsh", "interface", "ipv6", "set", "interface",
		name, "disabled")
	if output, err := disableIPv6Cmd.CombinedOutput(); err != nil {
		debugLog("Failed to disable IPv6: %v\nOutput: %s", err, output)
	}

	// Set interface up using netsh
	setUpCmd := exec.Command("netsh", "interface", "set", "interface",
		name, "admin=enabled")

	if output, err := setUpCmd.CombinedOutput(); err != nil {
		debugLog("Failed to enable interface: %v\nOutput: %s", err, output)
	}

	debugLog("Interface configuration completed")

	return &TunDevice{
		adapter: adapter,
		session: session,
		name:    name,
	}, nil
}

func (tun *TunDevice) Read(packet []byte) (int, error) {
	data, err := tun.session.ReceivePacket()
	if err != nil {
		if err == windows.ERROR_NO_MORE_ITEMS {
			return 0, nil
		}
		return 0, fmt.Errorf("error receiving from Wintun: %v", err)
	}

	// Validate packet
	if len(data) < 20 { // Minimum IP header size
		debugLog("Received undersized packet: %d bytes", len(data))
		return 0, nil
	}

	// Check IP version
	version := data[0] >> 4
	if version != 4 && version != 6 {
		debugLog("Invalid IP version: %d", version)
		return 0, nil
	}

	copy(packet, data)
	return len(data), nil
}

func (tun *TunDevice) Write(packet []byte) (int, error) {
	tun.session.SendPacket(packet)
	return len(packet), nil
}

func (tun *TunDevice) Close() error {
	if tun.adapter != nil {
		tun.session.End()
		tun.adapter.Close()
	}
	return nil
}

func (tun *TunDevice) Name() string {
	return tun.name
}
